
viterbi.hmm <- function(transitions, loglikelihood, positions) {
  if ( nrow(transitions) != ncol(transitions) ) stop("Transition matrix is not square")
  nstates <- nrow(transitions)
  nobs <- nrow(loglikelihood)
  
  res <- .Call("C_hmm", nstates, nobs, transitions, loglikelihood, positions, PACKAGE = 'ExoDepth') 
  dimnames(res[[2]])[[2]] <- c('start.p', 'end.p', 'type', 'nexons')
  res[[2]] <- as.data.frame(res[[2]])
  names(res) <- c('Viterbi.path', 'calls')
  
  return(res)
}



qbetabin <- function(p, size, phi, prob) {  ##parameterize with phi, prob instead of a,b
  require(VGAM)
  a <- prob*(1-phi)/phi
  b <- (1-prob)*(1-phi)/phi
  return( qbetabin.ab (p = p, size = size, shape1 = a, shape2 = b)  )
}


#qbetabin.ab <- function(p, size, shape1, shape2) {
#  require(VGAM)
#  my.p <- dbetabin.ab (x = 0:size, , size = size, shape1 = shape1, shape2 = shape2)
#  return(which( cumsum(my.p) > p)[1] -1)
#}


qbetabin.ab <- function (p, size, shape1, shape2)  {
    require(VGAM)
    my.p <- dbetabin.ab(x = 0:size, , size = size, shape1 = shape1, shape2 = shape2)
    cs <- cumsum(my.p)
    above <- which(cs > p)[1]
    below <- above - 1

    if (below > 0) {
      return (below + (p - cs[below])/my.p[ above ])
    } else {
      return (p/my.p[1])
    }
}
